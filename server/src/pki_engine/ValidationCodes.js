/******************************************************************************
 *  Copyright 2019 ModusBox, Inc.                                             *
 *                                                                            *
 *  info@modusbox.com                                                         *
 *                                                                            *
 *  Licensed under the Apache License, Version 2.0 (the "License");           *
 *  you may not use this file except in compliance with the License.          *
 *  You may obtain a copy of the License at                                   *
 *  http://www.apache.org/licenses/LICENSE-2.0                                *
 *                                                                            *
 *  Unless required by applicable law or agreed to in writing, software       *
 *  distributed under the License is distributed on an "AS IS" BASIS,         *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
 *  See the License for the specific language governing permissions and       *
 *  limitations under the License.                                            *
 ******************************************************************************/

module.exports = {
  VALID_STATES: {
    VALID: 'VALID',
    INVALID: 'INVALID',
    NOT_AVAILABLE: 'NOT_AVAILABLE'
  },
  VALIDATION_CODES: {
    CSR_CERT_SAME_PUBLIC_KEY: {
      code: 'CSR_CERT_SAME_PUBLIC_KEY',
      description: 'The CSR and the Certificate must have the same Public Key'
    },
    CSR_CERT_SAME_SUBJECT_INFO: {
      code: 'CSR_CERT_SAME_SUBJECT_INFO',
      description:
        'The CSR and the Certificate must have the same Subject Information ( distinguished name and extensions )'
    },
    CSR_CERT_SAME_CN: {
      code: 'CSR_CERT_SAME_CN',
      description:
        `The CSR and the Certificate must have the same CN. This was created because some external CAs change some subject info in the certificate, so we can't use CSR_CERT_SAME_SUBJECT_INFO`
    },
    CSR_CERT_PUBLIC_PRIVATE_KEY_MATCH: {
      code: 'CSR_CERT_PUBLIC_PRIVATE_KEY_MATCH',
      description:
        "The Certificate Public Key must match the private key used to sign the CSR. Only available if the CSR was created by the Connection-Manager. If the CSR was uploaded instead of generated by the Connection Manager, and there's no private key associated, this will be set the state to NOT_AVAILABLE"
    },
    CSR_MANDATORY_DISTINGUISHED_NAME: {
      code: 'CSR_MANDATORY_DISTINGUISHED_NAME',
      description: 'Distinguished names are mandatory in CSRs when creating TLS client certificates'
    },
    CERTIFICATE_SIGNED_BY_DFSP_CA: {
      code: 'CERTIFICATE_SIGNED_BY_DFSP_CA',
      description:
        'The Certificate should be signed by the DFSP CA. data.result = TRUST_CHAIN_VALID or SELF_SIGNED or INVALID or NOT_AVAILABLE if the ca info is not present'
    },
    CERTIFICATE_VALIDITY: {
      code: 'CERTIFICATE_VALIDITY',
      description:
        'The certificate must be valid at present time according to the certificate validity period'
    },
    CERTIFICATE_USAGE_CLIENT: {
      code: 'CERTIFICATE_USAGE_CLIENT',
      description:
        'The certificate must have the "TLS WWW client authentication" key usage extension. See https://tools.ietf.org/html/rfc5280#section-4.2.1.12'
    },
    CSR_SIGNATURE_VALID: {
      code: 'CSR_SIGNATURE_VALID',
      description:
        'The CSR must have a valid signature ( the signature matches the public key )'
    },
    CSR_PUBLIC_KEY_LENGTH_2048: {
      code: 'CSR_PUBLIC_KEY_LENGTH_2048',
      description:
        'The CSR key length must be at least 2048 bits',
      param: 2048
    },
    CSR_PUBLIC_KEY_LENGTH_4096: {
      code: 'CSR_PUBLIC_KEY_LENGTH_4096',
      description:
        'The CSR key length must be at least 4096 bits',
      param: 4096
    },
    CERTIFICATE_PUBLIC_KEY_LENGTH_2048: {
      code: 'CERTIFICATE_PUBLIC_KEY_LENGTH_2048',
      description:
        'The CERTIFICATE key length must be at least 2048 bits',
      param: 2048
    },
    CERTIFICATE_PUBLIC_KEY_LENGTH_4096: {
      code: 'CERTIFICATE_PUBLIC_KEY_LENGTH_4096',
      description:
        'The CERTIFICATE key length must be at least 4096 bits',
      param: 4096
    },
    CSR_SIGNATURE_ALGORITHM_SHA256_512: {
      code: 'CSR_SIGNATURE_ALGORITHM',
      description:
        'The CSR signature algorithm must be "sha256WithRSAEncryption" or "sha512WithRSAEncryption"',
      param: ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']
    },
    CERTIFICATE_USAGE_SERVER: {
      code: 'CERTIFICATE_USAGE_SERVER',
      description:
        'The certificate must have the "TLS WWW server authentication" key usage extension. See https://tools.ietf.org/html/rfc5280#section-4.2.1.12'
    },
    CERTIFICATE_CHAIN: {
      code: 'CERTIFICATE_CHAIN',
      description:
        'The certificate and its chain must form a valid trust chain. See https://tools.ietf.org/html/rfc5280#section-6.1'
    },
    CA_CERTIFICATE_USAGE: {
      code: 'CA_CERTIFICATE_USAGE',
      description:
        'Root and intermediate CAs certificates must have the CA basic contraint extension ( CA = true ) and the keyCertSign key usage extension. See https://tools.ietf.org/html/rfc5280#section-4.2.1.3 and https://tools.ietf.org/html/rfc5280#section-4.2.1.9'
    },
    CERTIFICATE_VALID_OCSP: {
      code: 'CERTIFICATE_VALID_OCSP',
      description:
        'The certificate must be valid according to the Online Certificate Status Protocol (OCSP) [RFC2560]. **PENDING** may be included in the CERTIFICATE_VALIDITY operation.'
    },
    CERTIFICATE_VALID_CRL: {
      code: 'CERTIFICATE_VALID_CRL',
      description:
        'The certificate must be valid according to the certificate revocation lists (CRLs) info. At the current time, the certificate is not revoked. See https://tools.ietf.org/html/rfc5280#section-6.3 . **PENDING** may be included in the CERTIFICATE_VALIDITY operation.'
    },
    VERIFY_ROOT_CERTIFICATE: {
      code: 'VERIFY_ROOT_CERTIFICATE',
      description: 'Verifies the certificate as a root certificate. It can be self-signed or signed by a global root. Global root depends on the engine root certificates list, so this condition may change over time. Ref: https://www.openssl.org/docs/man1.0.2/man1/openssl-verify.html',
    },
    VERIFY_CHAIN_CERTIFICATES: {
      code: 'VERIFY_CHAIN_CERTIFICATES',
      description: 'the intermediateChain is made of valid CAs and the top of the chain is signed by the root',
    },
    CERTIFICATE_ALGORITHM_SHA256: {
      code: 'CERTIFICATE_SIGNATURE_ALGORITHM',
      description:
        'The certificate signature algorithm must be "sha256WithRSAEncryption"',
      param: 'sha256WithRSAEncryption'
    },
  }
};
